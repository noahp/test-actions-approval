#!/usr/bin/env python3

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

import re
import subprocess
import sys


def get_commit_title(sha):
    return (
        subprocess.check_output(["git", "log", "-1", "--pretty=%s", sha])
        .decode("utf-8")
        .strip()
    )


def main():
    remote = sys.argv[1]
    url = sys.argv[2]

    youtrack_ids = []
    for line in sys.stdin:
        local_ref, local_sha, remote_ref, remote_sha = line.split()
        if local_sha == "0000000000000000000000000000000000000000":
            # Handle delete
            pass
        else:
            # Handle create or update
            if remote_sha == "0000000000000000000000000000000000000000":
                # create
                # New branch, examine all commits
                range = local_sha
            else:
                # Update to existing branch, examine new commits
                range = f"{remote_sha}..{local_sha}"

            # from the default example. but TODO, the above doesn't seem to get
            # all the commits being pushed :(
            #
            # # Check for WIP commit
            # commit=$(git rev-list -n 1 --grep '^WIP' "$range")

            # Pushing commits. Get the title and save if it has a YouTrack ID
            title = get_commit_title(local_sha)
            match = re.search(r"((?:(?:mflt)|(?:MFLT))+-\d+)", title)
            if match:
                youtrack_ids.append(match.group(1))

    dupes = []
    if len(youtrack_ids) > 0:
        print("Pushing commits with YouTrack IDs: {}".format(", ".join(youtrack_ids)))
        # for each youtrack id found, check if it exists on another commit
        # if it does, print a warning!
        for youtrack_id in youtrack_ids:
            try:
                dupe = (
                    subprocess.check_output(
                        f"git log --all --pretty='format:%H %s' | grep {youtrack_id}",
                        shell=True,
                    )
                    .decode("utf-8")
                    .strip()
                )
                if dupe:
                    print(
                        f"WARNING: YouTrack ID {youtrack_id} found in existing commit {dupe.split()[0]}!"
                    )
                    dupes.append(dupe)
            except subprocess.CalledProcessError:
                # No dupe found
                continue
    if dupes:
        exit(1)


if __name__ == "__main__":
    main()
